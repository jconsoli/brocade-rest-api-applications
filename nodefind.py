#!/usr/bin/python
# -*- coding: utf-8 -*-
"""
Copyright 2024 Consoli Solutions, LLC.  All rights reserved.

**License**

Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
the License. You may also obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific
language governing permissions and limitations under the License.

The license is free for single customer use (internal applications). Use of this module in the production,
redistribution, or service delivery for commerce requires an additional license. Contact jack@consoli-solutions.com for
details.

**Description**

Performs a node find in a project

ToDo Add zones. Maybe add zone. Add comment action to workbook. If -i doesn't exist, error message is incorrect

**Version Control**

+-----------+---------------+-----------------------------------------------------------------------------------+
| Version   | Last Edit     | Description                                                                       |
+===========+===============+===================================================================================+
| 1.0.0     | 03 Apr 2024   | Initial launch                                                                    |
+-----------+---------------+-----------------------------------------------------------------------------------+
"""
__author__ = 'Jack Consoli'
__copyright__ = 'Copyright 2024 Consoli Solutions, LLC'
__date__ = '03 Apr 2024'
__license__ = 'Apache License, Version 2.0'
__email__ = 'jack@consoli-solutions.com'
__maintainer__ = 'Jack Consoli'
__status__ = 'Released'
__version__ = '1.0.0'

import os
import brcdapi.log as brcdapi_log
import brcdapi.gen_util as gen_util
import brcdapi.excel_util as excel_util
import brcdapi.file as brcdapi_file
import brcddb.brcddb_common as brcddb_common
import brcddb.brcddb_project as brcddb_project
import brcddb.brcddb_switch as brcddb_switch
import brcddb.util.search as brcddb_search
import brcddb.report.login as report_login
import brcddb.brcddb_fabric as brcddb_fabric
import brcddb.brcddb_login as brcddb_login
import brcddb.brcddb_port as brcddb_port
_version_d = dict(
    brcdapi_log=brcdapi_log.__version__,
    gen_util=gen_util.__version__,
    excel_util=excel_util.__version__,
    brcdapi_file=brcdapi_file.__version__,
    brcddb_common=brcddb_common.__version__,
    brcddb_project=brcddb_project.__version__,
    brcddb_switch=brcddb_switch.__version__,
    brcddb_search=brcddb_search.__version__,
    report_login=report_login.__version__,
    brcddb_fabric=brcddb_fabric.__version__,
    brcddb_login=brcddb_login.__version__,
    brcddb_port=brcddb_port.__version__,
)

_DOC_STRING = False  # Should always be False. Prohibits any code execution. Only useful for building documentation
# _STAND_ALONE: True: Executes as a standalone module taking input from the command line. False: Does not automatically
# execute. This is useful when importing this module into another module that calls psuedo_main().
_STAND_ALONE = True  # See note above

_search_type_d = dict(wild='wild', regex_m='regex-m', regex_s='regex-s', exact='exact')
_search_type_l = [str(_b) for _b in _search_type_d.keys()]

_input_d = dict(
    i=dict(h='Required. Name of input file generated by capture.py, combine.py, or multi_capture.py. ".json" is '
             'automatically appended if not present.'),
    alias=dict(r=False, d=None,
               h='Optional. CSV list of nodes by alias to search for. Supports regex and wild card searching. If the '
                 'regex contains a comma, don\'t forget to encapsulate it with quotes. Duplicates are removed.'),
    alias_f=dict(r=False, d=None,
                 h='Optional. A CSV list of plain text files containing the aliases to search for. The default file '
                   'extension is ".txt". The content is the same as -alias. Comments and blank lines are ignored. '
                   'Each alias must be on a separate line. You may specify both -alias and -alias_f. Duplicates are '
                   'removed.'),
    wwn=dict(r=False, d=None,
             h='Optional. CSV list of nodes by WWN to search for. Supports regex and wild card searching. If the '
               'regex contains a comma, don\'t forget to encapsulate it with quotes. Duplicates are removed.'),
    wwn_f=dict(r=False, d=None,
               h='Optional. A CSV list of plain text files containing the WWNs to search for. The default file '
                 'extension is ".txt". The content is the same as -wwn. Comments and blank lines are ignored. Each '
                 'WWN must be on a separate line. You may specify both -wwn and -wwn_f. Duplicates are removed.'),
    s=dict(r=False, d='exact', v=_search_type_l,
           h='Optional. Search type. Options are: ' + ', '.join(_search_type_l) + ' The default is "exact".'),
    r=dict(r=False, h='Optional. Name of Excel report file. ".xlsx" is automatically appended.'),
)
_input_d.update(gen_util.parseargs_log_d.copy())

_wb = None  # Object for the Excel workbook used for output
_proj_obj = None  # Project object
_report_name = None  # Name of report
_working_obj_l = list()
_report_display = dict()
_sheet_index = 0  # Most examples add a worksheet to the Excel workbook. This indicates where.
_MAX_LINE_LEN = 72  # Used to control how long help messages can be.


def _local_report(search_d):
    """Create a text report for each search term

    :param search_d: Key is the search term and value is the list of login objects associated with that search term
    :type search_d: dict
    :return: None
    :rtype: None
    """
    ml = ['', 'Node Find Results', '_________________']
    for k, login_obj_l in search_d.items():
        ml.extend(['', str(k)])
        if len(login_obj_l) == 0:
            ml.append('  Not found.')
        for login_obj in login_obj_l:
            port_obj = login_obj.r_port_obj()
            if port_obj is None:
                ml.append('  Port not found for ' + login_obj.r_obj_key() +
                          '. This typically occurs when there was an incomplete data capture.')
                continue
            login_name = brcddb_login.best_login_name(login_obj.r_fabric_obj(), login_obj.r_obj_key(), flag=True)
            switch_name = brcddb_switch.best_switch_name(port_obj.r_switch_obj(), wwn=True, fid=True, did=True)
            ml.extend([
                '  Name:        ' + login_name,
                '  Switch:      ' + switch_name,
                '  Port:        ' + brcddb_port.best_port_name(port_obj, port_num=True),
                '  Description: ' + brcddb_port.port_best_desc(port_obj),
                '',
                ])
    brcdapi_log.log(ml, echo=True)


def _excel_report(report, search_d):
    """Create an Excel report for each search term found

    :param report: Name of report file. If None, a report will not be created
    :type report: str, None
    :param search_d: Key is the search term and value is the list of login objects associated with that search term
    :type search_d: dict
    :return: None
    :rtype: None
    """
    if report is None:
        return
    wb = excel_util.new_report()
    sheet_name = 'Node Find Results'
    report_obj_l = list()
    for k, login_obj_l in search_d.items():
        report_obj_l.extend(login_obj_l)
    report_login.login_page(wb, None, sheet_name, 0, sheet_name, report_obj_l)

    try:
        excel_util.save_report(wb, report)
    except FileNotFoundError:
        brcdapi_log.log('Folder in ' + report + ' not found.')
    except PermissionError:
        buf = ('Permission denied writing ' + report +
               '. This typically happens when the file is open in another application')
        brcdapi_log.log(buf, echo=True)


def psuedo_main(proj_obj, alias_l, wwn_l, search_type, report):
    """Basically the main().

    :param proj_obj: Project object
    :type proj_obj: brcdapi.class.project.ProjectObj
    :param alias_l: Nodes by alias to search for
    :type alias_l: list
    :param wwn_l: Nodes by WWN to search for
    :type wwn_l: list
    :param search_type: Type of search. Can be exact, regex_m, regex_s, or wild
    :type search_type: str
    :param report: Name of Excel report.
    :type report: None,str
    :return: Status code.
    :rtype: int
    """

    # Initialize tracking data structures
    search_d = dict()
    for buf in alias_l + wwn_l:
        search_d.update({buf: list()})

    # Find each item - nodefind
    for fab_obj in proj_obj.r_fabric_objects():

        # Find by alias. Doing this one alias at a time to keep track of what was found for each alias
        for alias in alias_l:  # Keep in mind that aliases may be a regex or wild card
            for alias_obj in [fab_obj.r_alias_obj(a) for a in
                              brcddb_fabric.aliases_by_name(fab_obj, alias, s_type=search_type)]:
                for wwn in alias_obj.r_members():
                    login_obj = fab_obj.r_login_obj(wwn)
                    if login_obj is not None:
                        search_d[alias].append(login_obj)

        # Find by WWN. Doing this one WWN at a time to keep track of what was found for each WWN. Keep in mind that
        # WWNs may be a regex or wild card
        for wwn in wwn_l:
            search_d[wwn].extend(brcddb_search.match(fab_obj.r_login_objects(), '_obj_key', wwn, True, search_type))

    # Create the reports
    _local_report(search_d)
    _excel_report(report, search_d)

    return brcddb_common.EXIT_STATUS_OK


def _get_input():
    """Parses the module load command line

    :return ec: Status code.
    :rtype ec: int
    """
    global __version__, _input_d, _version_d, _search_type_d

    ec = brcddb_common.EXIT_STATUS_OK

    # Get command line input
    try:
        args_d = gen_util.get_input('Searches a project file for a node.', _input_d)
    except TypeError:
        return brcddb_common.EXIT_STATUS_INPUT_ERROR  # gen_util.get_input() already posted the error message.

    # Set up logging
    brcdapi_log.open_log(folder=args_d['log'], supress=args_d['sup'], no_log=args_d['nl'], version_d=_version_d)

    # Read in the project file
    proj_obj, args_i_help = None, ''
    try:
        proj_obj = brcddb_project.read_from(brcdapi_file.full_file_name(args_d['i'], '.json'))
        if proj_obj is None:  # Error messages are sent to the log in brcddb_project.read_from() if proj_obj is None
            return brcddb_common.EXIT_STATUS_INPUT_ERROR
        brcddb_project.build_xref(proj_obj)
    except FileNotFoundError:
        args_i_help = ' not found'
        ec = brcddb_common.EXIT_STATUS_INPUT_ERROR
    except FileExistsError:
        args_i_help = ' folder does not exist.'
        ec = brcddb_common.EXIT_STATUS_INPUT_ERROR

    # Command line feedback
    ml = [os.path.basename(__file__) + ', ' + __version__,
          'Project, -i:          ' + args_d['i'] + args_i_help,
          'WWN, -wwn:            ' + str(args_d['wwn']),
          'WWN file, -wwn_f:     ' + str(args_d['wwn_f']),
          'Alias, -alias:        ' + str(args_d['alias']),
          'Alias file, -alias_f: ' + str(args_d['alias_f']),
          'Search type, -s:      ' + str(args_d['s']),
          'Report, -r:           ' + str(args_d['r']),
          'Log, -log:            ' + str(args_d['log']),
          'No log, -nl:          ' + str(args_d['nl']),
          'Supress, -sup:        ' + str(args_d['sup']),]
    proj_obj.s_description('\n'.join(ml))
    ml.append('')

    # Get the lists of aliases and WWNs to work on.
    alias_l = list() if args_d['alias'] is None else gen_util.convert_to_list(args_d['alias'].split(','))
    wwn_l = list() if args_d['wwn'] is None else gen_util.convert_to_list(args_d['wwn'].split(','))
    for d in (dict(f=args_d['alias_f'], l=alias_l), dict(f=args_d['wwn_f'], l=wwn_l)):
        if isinstance(d['f'], str):
            for file in d['f'].split(','):
                try:
                    d['l'].extend(brcdapi_file.read_file(brcdapi_file.full_file_name(file, '.txt', dot=True)))
                except FileNotFoundError:
                    ml.append(str(file) + ' does not exist')
                    ec = brcddb_common.EXIT_STATUS_INPUT_ERROR
                except FileExistsError:
                    ml.append('A folder in ' + str(file) + ' does not exist')
                    ec = brcddb_common.EXIT_STATUS_INPUT_ERROR

    # Validate the WWNs and aliases
    if len(alias_l) + len(wwn_l) == 0:
        ml.append('No nodes to search for.')
        ec = brcddb_common.EXIT_STATUS_INPUT_ERROR
    elif args_d['s'] == 'exact':
        for wwn in wwn_l:
            if not gen_util.is_wwn(wwn):
                ml.append(wwn + ', is not valid a valid WWN for exact match. Re-run with -h and review the -s options.')
                ec = brcddb_common.EXIT_STATUS_INPUT_ERROR
        for alias in alias_l:
            if not gen_util.is_valid_zone_name(alias):
                ml.append(alias + ', is not a valid alias for exact match. Re-run with -h and review the -s options.')
                ec = brcddb_common.EXIT_STATUS_INPUT_ERROR

    # Prepare the list and send feedback to the log, echo to STD_OUT
    # I can't think of any reason why I would have to remove None, but it's only a few extra CPU cycles
    alias_l = gen_util.remove_duplicates(gen_util.remove_none(alias_l))
    wwn_l = gen_util.remove_duplicates(gen_util.remove_none(wwn_l))
    brcdapi_log.log(ml, echo=True)

    if ec != brcddb_common.EXIT_STATUS_OK:
        return ec
    return psuedo_main(proj_obj,
                       alias_l,
                       wwn_l,
                       _search_type_d[args_d['s']],
                       brcdapi_file.full_file_name(args_d['r'], '.xlsx'))


##################################################################
#
#                    Main Entry Point
#
###################################################################
if _DOC_STRING:
    print('_DOC_STRING is True. No processing')
    exit(0)

if _STAND_ALONE:
    _ec = _get_input()
    brcdapi_log.close_log(['', 'Processing Complete. Exit code: ' + str(_ec)], echo=True)
    exit(_ec)
